#include "helper.h"
#include "visualLB.h"
#include <stdio.h>
#include "LBDefinitions.h"

void writeVtkOutput(const double * const collideField,
		const int * const flagField, const char* filename, unsigned int t,
		int xlength) {
	/* TODO */
	int i, j, k, q;
	double cellDensity, fi, xVelocity, yVelocity, zVelocity;
	char szFileName[80];

	FILE *fp = NULL;
	sprintf(szFileName, "%s.%i.vtk", filename, t);
	fp = fopen(szFileName, "w");
	if (fp == NULL ) {
		char szBuff[80];
		sprintf(szBuff, "Failed to open %s", szFileName);
		ERROR( szBuff);
		return;
	}

	writeVtkHeader(fp, xlength);
	writeVtkPointCoordinates(fp, xlength);

	fprintf(fp, "POINT_DATA %i \n",
			(xlength + 1) * (xlength + 1) * (xlength + 1));

	fprintf(fp, "\n");

	fprintf(fp, "VECTORS velocity float\n");
	for (j = 0; j < xlength + 1; j++) {
		for (i = 0; i < xlength + 1; i++) {
			for (k = 0; k < xlength + 1; k++) {
				cellDensity = 0.0;
				xVelocity = 0.0;
				yVelocity = 0.0;
				zVelocity = 0.0;
				/* Calculating the density in each cell according to Eq. 9
				 * in the assignment sheet and considering the lexicographic
				 *  order for storing the data. */
				for (q = 0; q < 19; q++) {
					fi = collideField[19
							* (k * xlength * xlength + j * xlength + i) + q];
					cellDensity = cellDensity + fi;
					xVelocity = fi * LATTICEVELOCITIES[q][0];
					yVelocity = fi * LATTICEVELOCITIES[q][1];
					zVelocity = fi * LATTICEVELOCITIES[q][2];
				}
				xVelocity = xVelocity / cellDensity;
				yVelocity = yVelocity / cellDensity;
				zVelocity = zVelocity / cellDensity;
				fprintf(fp, "%f %f %f\n", xVelocity, yVelocity, zVelocity);
			}
		}
	}

	fprintf(fp, "\n");
	fprintf(fp, "CELL_DATA %i \n", ((xlength) * (xlength) * (xlength)));
	fprintf(fp, "SCALARS density float 1\n");
	fprintf(fp, "LOOKUP_TABLE default \n");
	for (j = 0; j < xlength + 1; j++) {
		for (i = 0; i < xlength + 1; i++) {
			for (k = 0; k < xlength + 1; k++) {
				cellDensity = 0.0;
				/* Calculating the density in each cell according to Eq. 9
				 * in the assignment sheet and considering the lexicographic
				 *  order for storing the data. */
				for (q = 0; q < 19; q++) {
					cellDensity = cellDensity
							+ collideField[19
									* (k * xlength * xlength + j * xlength + i)
									+ q];
				}
				fprintf(fp, "%f\n", cellDensity);
			}
		}
	}

	if (fclose(fp)) {
		char szBuff[80];
		sprintf(szBuff, "Failed to close %s", szFileName);
		ERROR( szBuff);
	}

}

void writeVtkHeader(FILE *fp, int xlength) {
	if (fp == NULL ) {
		char szBuff[80];
		sprintf(szBuff, "Null pointer in write_vtkHeader");
		ERROR( szBuff);
		return;
	}

	fprintf(fp, "# vtk DataFile Version 2.0\n");
	fprintf(fp, "generated by CFD-lab course output \n");
	fprintf(fp, "ASCII\n");
	fprintf(fp, "\n");
	fprintf(fp, "DATASET STRUCTURED_GRID\n");
	fprintf(fp, "DIMENSIONS  %i %i %i \n", xlength + 2, xlength + 2,
			xlength + 2);
	fprintf(fp, "POINTS %i float\n",
			(xlength + 2) * (xlength + 2) * (xlength + 2));
	fprintf(fp, "\n");
}

void writeVtkPointCoordinates(FILE *fp, int xlength) {
	double originX = 0.0;
	double originY = 0.0;
	double originZ = 0.0;

	int i = 0;
	int j = 0;
	int k = 0;

	for (j = 0; j < xlength + 1; j++) {
		for (i = 0; i < xlength + 1; i++) {
			for (k = 0; k < xlength + 1; k++) {
				fprintf(fp, "%f %f %f \n", originX + i, originY + j,
						originZ + k);
			}
		}
	}
}
